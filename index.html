<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Galaxy Runner 3D Pro</title>
<style>
  body { margin: 0; overflow: hidden; background:#000; font-family: sans-serif; }
  #ui { position: absolute; top: 10px; left: 10px; color: #0ff; font-weight: bold; font-size: 20px; text-shadow: 0 0 10px #0ff; }
  #health { color: #ff0055; margin-left: 20px; }
  canvas { display:block; }
</style>
</head>
<body>
<div id="ui">SCORE: <span id="s">0</span> <span id="health">HP: 3</span></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000510);
scene.fog = new THREE.FogExp2(0x000510, 0.02); // Add depth fog

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, -8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
const ambient = new THREE.AmbientLight(0x404040); scene.add(ambient);
const light = new THREE.PointLight(0x00ffff, 2, 50); light.position.set(0, 10, 0); scene.add(light);

// Player (Advanced Ship Shape)
const playerGroup = new THREE.Group();
const body = new THREE.Mesh(new THREE.ConeGeometry(0.5, 2, 4), new THREE.MeshStandardMaterial({color: 0x00e5ff}));
body.rotation.x = Math.PI/2;
playerGroup.add(body);
const wings = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 0.5), new THREE.MeshStandardMaterial({color: 0x0088ff}));
playerGroup.add(wings);
playerGroup.position.set(0, 0.5, 0);
scene.add(playerGroup);

// Ground (Space Path)
const groundGeo = new THREE.PlaneGeometry(12, 2000);
const groundMat = new THREE.MeshStandardMaterial({color: 0x111122, side: THREE.DoubleSide});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = Math.PI/2;
ground.position.z = 1000;
scene.add(ground);

// Stars
const starGeo = new THREE.BufferGeometry();
const starCount = 2000;
const posArray = new Float32Array(starCount * 3);
for(let i=0; i<starCount*3; i++) posArray[i] = (Math.random()-0.5) * 200;
starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
const starMat = new THREE.PointsMaterial({size: 0.1, color: 0xffffff});
const starField = new THREE.Points(starGeo, starMat);
scene.add(starField);

// Game State
const lanes = [-3, 0, 3];
let currentLane = 1, speed = 0.5, score = 0, health = 3;
let obstacles = [], orbs = [];

// SWIPE CONTROLS for Mobile
let touchStartX = 0;
document.addEventListener('touchstart', e => touchStartX = e.touches[0].clientX);
document.addEventListener('touchend', e => {
  let diff = e.changedTouches[0].clientX - touchStartX;
  if (diff > 50) currentLane = Math.min(2, currentLane + 1);
  if (diff < -50) currentLane = Math.max(0, currentLane - 1);
});

// PC Controls
document.addEventListener('keydown', e => {
  if(e.key==='ArrowLeft') currentLane = Math.max(0, currentLane-1);
  if(e.key==='ArrowRight') currentLane = Math.min(2, currentLane+1);
});

function spawn() {
  const lane = lanes[Math.floor(Math.random()*3)];
  const z = camera.position.z + 100;
  
  // Spawn Obstacle
  const obs = new THREE.Mesh(new THREE.IcosahedronGeometry(0.8, 0), new THREE.MeshStandardMaterial({color:0xff3300}));
  obs.position.set(lane, 0.8, z);
  scene.add(obs); obstacles.push(obs);

  // Spawn Orb
  const orb = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({color:0x00ff00, emissive: 0x00ff00}));
  orb.position.set(lanes[Math.floor(Math.random()*3)], 0.8, z + 10);
  scene.add(orb); orbs.push(orb);
}
setInterval(spawn, 1000);

function animate() {
  requestAnimationFrame(animate);

  // Movement
  playerGroup.position.x += (lanes[currentLane] - playerGroup.position.x) * 0.1;
  camera.position.z += speed;
  playerGroup.position.z = camera.position.z + 5;
  starField.position.z = camera.position.z;

  // Obstacle Collision
  obstacles.forEach((o, i) => {
    if(o.position.distanceTo(playerGroup.position) < 1.2) {
      scene.remove(o); obstacles.splice(i, 1);
      health--; document.getElementById('health').innerText = "HP: "+health;
      if(health <= 0) { alert("Game Over! Score: " + score); location.reload(); }
    }
  });

  // Orb Collection
  orbs.forEach((orb, i) => {
    if(orb.position.distanceTo(playerGroup.position) < 1.2) {
      scene.remove(orb); orbs.splice(i, 1);
      score += 50; speed += 0.005;
      document.getElementById('s').innerText = score;
    }
  });

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>

