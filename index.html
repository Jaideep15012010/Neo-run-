<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GALAXY TEMPLE PRO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; }
        #gameUI { position: absolute; top: 20; left: 20; color: #0ff; z-index: 50; pointer-events: none; }
        .screen { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.9); z-index: 100; text-align: center; }
        .btn { background: #0ff; color: #000; padding: 15px 40px; border: none; font-size: 20px; border-radius: 5px; cursor: pointer; font-family: 'Orbitron'; margin: 10px; }
        #shop { display: none; background: #001122; border: 2px solid #0ff; width: 80%; height: 70%; overflow-y: auto; padding: 20px; }
    </style>
</head>
<body>

<div id="gameUI">SCORE: <span id="scr">0</span> | BEST: <span id="bst">0</span></div>

<div id="menu" class="screen">
    <h1 style="color:#0ff; font-size: 50px;">GALAXY RUN 2</h1>
    <button class="btn" onclick="Engine.start()">PLAY NOW</button>
    <button class="btn" style="background:#f0f" onclick="toggleShop(true)">UPGRADE SHOP</button>
</div>

<div id="gameOver" class="screen" style="display:none">
    <h1 style="color:red">MISSION FAILED</h1>
    <p style="color:white">FINAL SCORE: <span id="finalScore">0</span></p>
    <button class="btn" onclick="Engine.start()">RETRY</button>
    <button class="btn" onclick="location.reload()">HOME</button>
</div>

<div id="shop" class="screen">
    <h2>GALAXY SHOP</h2>
    <p>Current Gems: <span id="gems">0</span></p>
    <button class="btn" onclick="buyItem('Shield')">SHIELD (100 Gems)</button>
    <button class="btn" onclick="buyItem('Magnet')">MAGNET (200 Gems)</button><br>
    <button class="btn" style="background:red" onclick="toggleShop(false)">CLOSE</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const Engine = {
    active: false,
    score: 0,
    speed: 0.7,
    
    init() {
        World.setup();
        Player.setup();
        this.loop();
    },
    
    start() {
        document.getElementById('menu').style.display = 'none';
        document.getElementById('gameOver').style.display = 'none';
        this.score = 0;
        this.speed = 0.7;
        this.active = true;
        Player.reset();
        World.reset();
    },

    over() {
        this.active = false;
        document.getElementById('gameOver').style.display = 'flex';
        document.getElementById('finalScore').innerText = Math.floor(this.score);
        let b = localStorage.getItem('bst') || 0;
        if(this.score > b) localStorage.setItem('bst', Math.floor(this.score));
    },

    loop() {
        requestAnimationFrame(() => this.loop());
        if(!this.active) return;
        
        Player.update();
        World.update();
        this.score += 0.1;
        document.getElementById('scr').innerText = Math.floor(this.score);
        document.getElementById('bst').innerText = localStorage.getItem('bst') || 0;
        Renderer.render();
    }
};

const Renderer = {
    scene: new THREE.Scene(),
    camera: new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000),
    webGL: new THREE.WebGLRenderer({antialias: true}),

    setup() {
        this.webGL.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.webGL.domElement);
        this.scene.background = new THREE.Color(0x000510);
        this.scene.fog = new THREE.FogExp2(0x000510, 0.04);
        this.camera.position.set(0, 5, -8);
        this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    },
    render() {
        this.camera.position.z = Player.mesh.position.z - 8;
        this.camera.lookAt(0, 2, Player.mesh.position.z + 5);
        this.webGL.render(this.scene, this.camera);
    }
};

const Player = {
    mesh: new THREE.Group(),
    lane: 0,
    vy: 0,

    setup() {
        // Create 3D Humanoid Body
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshStandardMaterial({color: 0x00ffff}));
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.8,1.2,0.4), new THREE.MeshStandardMaterial({color: 0x0088ff}));
        head.position.y = 1.5; body.position.y = 0.7;
        this.mesh.add(head, body);
        Renderer.scene.add(this.mesh);
        
        // Mobile Controls
        let startX = 0;
        window.addEventListener('touchstart', e => startX = e.touches[0].clientX);
        window.addEventListener('touchend', e => {
            let diff = e.changedTouches[0].clientX - startX;
            if(diff > 50) this.lane = Math.min(1, this.lane + 1);
            if(diff < -50) this.lane = Math.max(-1, this.lane - 1);
        });
    },

    update() {
        this.mesh.position.z += Engine.speed;
        this.mesh.position.x += (this.lane * 4 - this.mesh.position.x) * 0.1;
        
        // Animation "Breathe" effect
        this.mesh.children[1].scale.y = 1 + Math.sin(Date.now()*0.01)*0.05;
    },

    reset() {
        this.mesh.position.set(0, 0, 0);
        this.lane = 0;
    }
};

const World = {
    tiles: [], obstacles: [],

    setup() {
        for(let i=0; i<15; i++) this.addTile(i * 20);
    },

    addTile(z) {
        const tile = new THREE.Mesh(new THREE.PlaneGeometry(15, 20), new THREE.MeshStandardMaterial({color: 0x111122}));
        tile.rotation.x = -Math.PI/2; tile.position.z = z;
        Renderer.scene.add(tile); this.tiles.push(tile);
        if(z > 50) this.addObstacle(z);
    },

    addObstacle(z) {
        // 500+ Variations: Using Random heights/scales
        const h = Math.random() * 5 + 1;
        const obs = new THREE.Mesh(new THREE.BoxGeometry(3, h, 1), new THREE.MeshStandardMaterial({color: 0xff0055}));
        obs.position.set((Math.floor(Math.random()*3)-1)*4, h/2, z);
        Renderer.scene.add(obs); this.obstacles.push(obs);
    },

    update() {
        if(this.tiles[0].position.z < Player.mesh.position.z - 20) {
            let t = this.tiles.shift();
            t.position.z += this.tiles.length * 20 + 20;
            this.tiles.push(t);
            this.addObstacle(t.position.z);
        }

        this.obstacles.forEach((o, i) => {
            if(o.position.distanceTo(Player.mesh.position) < 1.5) Engine.over();
            if(o.position.z < Player.mesh.position.z - 20) {
                Renderer.scene.remove(o); this.obstacles.splice(i, 1);
            }
        });
    },

    reset() {
        this.obstacles.forEach(o => Renderer.scene.remove(o));
        this.obstacles = [];
    }
};

function toggleShop(show) { document.getElementById('shop').style.display = show ? 'flex' : 'none'; }
function buyItem(name) { alert(name + " purchased with Gems!"); }

Renderer.setup();
Engine.init();
</script>
</body>
</html>

