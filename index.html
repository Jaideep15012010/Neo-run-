<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JUNGLE RUN: ULTIMATE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #111; }
        canvas { display: block; }
        
        /* UI Design */
        #game-ui { position: absolute; top: 10px; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
        .score-board { color: gold; font-family: 'Black Ops One', cursive; font-size: 30px; text-shadow: 2px 2px #000; }
        
        .overlay { 
            position: absolute; inset: 0; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            background: linear-gradient(to bottom, rgba(0,20,0,0.8), rgba(0,0,0,0.9)); 
            z-index: 100; color: white; font-family: sans-serif;
        }
        
        .play-btn { 
            background: #ffcc00; color: #000; border: 4px solid #fff; 
            padding: 20px 80px; font-size: 28px; font-weight: 900; 
            border-radius: 15px; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 20px #ffcc00; transition: 0.2s;
        }
        .play-btn:active { transform: scale(0.9); }
    </style>
</head>
<body>

<div id="game-ui">
    <div class="score-board">SCORE: <span id="val">0</span></div>
</div>

<div id="start-screen" class="overlay">
    <h1 style="font-family: 'Black Ops One'; font-size: 50px; color: #00ff00; margin: 0;">JUNGLE RUN</h1>
    <p style="margin-bottom: 30px; letter-spacing: 2px;">V5.0 PRO MAX ENGINE</p>
    <div class="play-btn" id="start-trigger">START RUN</div>
</div>

<div id="dead-screen" class="overlay" style="display:none;">
    <h1 style="color: red; font-size: 60px;">WASTED</h1>
    <div class="play-btn" onclick="location.reload()">RETRY</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
/**
 * REWRITTEN GAME ENGINE v5.0
 * Zero Reliance on Old Structure
 */

const CONFIG = {
    laneDist: 4,
    moveSpeed: 1.3,
    jumpStr: 0.25,
    gravity: 0.015,
    tileLen: 40
};

let scene, camera, renderer, player, mixer, clock = new THREE.Clock();
let gameActive = false, score = 0, lane = 0, vy = 0;
let tiles = [], obstacles = [];

// NEW START LOGIC
const startTrigger = document.getElementById('start-trigger');
const startGame = () => {
    document.getElementById('start-screen').style.display = 'none';
    gameActive = true;
};
startTrigger.addEventListener('click', startGame);
startTrigger.addEventListener('touchstart', startGame);

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky
    scene.fog = new THREE.Fog(0x87CEEB, 20, 160);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Light
    const amb = new THREE.AmbientLight(0xffffff, 0.8);
    const sun = new THREE.DirectionalLight(0xffffff, 1);
    sun.position.set(10, 50, 10);
    scene.add(amb, sun);

    // Initial Tiles
    for(let i=0; i<10; i++) buildWorld(i * CONFIG.tileLen);

    // Fallback Player (If 3D model takes time)
    const pGeo = new THREE.BoxGeometry(1, 2, 1);
    const pMat = new THREE.MeshStandardMaterial({color: 0x00ff00, visible: false});
    player = new THREE.Mesh(pGeo, pMat);
    player.position.set(0, 1, 0);
    scene.add(player);

    // 3D Model Loading
    new THREE.GLTFLoader().load('https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb', (gltf) => {
        const model = gltf.scene;
        model.scale.set(0.4, 0.4, 0.4);
        model.rotation.y = Math.PI;
        player.add(model);
        player.children[0].visible = true;
        mixer = new THREE.AnimationMixer(model);
        const run = gltf.animations.find(a => a.name === 'Running');
        if(run) mixer.clipAction(run).play();
    });

    handleInput();
    loop();
}

function buildWorld(z) {
    // Road Tile
    const tGeo = new THREE.BoxGeometry(12, 0.5, CONFIG.tileLen);
    const tMat = new THREE.MeshStandardMaterial({color: 0x554433});
    const tile = new THREE.Mesh(tGeo, tMat);
    tile.position.z = z;
    // S-Curve Path
    tile.position.x = Math.sin(z * 0.025) * 8;
    scene.add(tile);
    tiles.push(tile);

    // Forest Background
    for(let j=0; j<2; j++) {
        const tree = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 1, 10), new THREE.MeshStandardMaterial({color: 0x2e1b0d}));
        tree.position.set(tile.position.x + (j===0 ? -12 : 12), 5, z + (Math.random()*20-10));
        scene.add(tree);
    }

    if(z > 80) spawnTraps(z, tile.position.x);
}

function spawnTraps(z, rx) {
    const isSlide = Math.random() > 0.7;
    const trap = new THREE.Mesh(
        isSlide ? new THREE.BoxGeometry(12, 1, 1) : new THREE.BoxGeometry(3.5, 2, 1),
        new THREE.MeshStandardMaterial({color: isSlide ? 0xffcc00 : 0xaa0000})
    );
    trap.position.set(isSlide ? rx : rx + (Math.floor(Math.random()*3)-1) * CONFIG.laneDist, isSlide ? 4.5 : 1.2, z);
    scene.add(trap);
    obstacles.push(trap);
}

function handleInput() {
    let xS, yS;
    window.addEventListener('touchstart', e => { xS = e.touches[0].clientX; yS = e.touches[0].clientY; });
    window.addEventListener('touchend', e => {
        let dX = e.changedTouches[0].clientX - xS;
        let dY = e.changedTouches[0].clientY - yS;
        if(Math.abs(dX) > Math.abs(dY)) {
            // FIXED CONTROLS: RIGHT = RIGHT, LEFT = LEFT
            if(dX > 40) lane = Math.min(1, lane + 1);
            if(dX < -40) lane = Math.max(-1, lane - 1);
        } else {
            if(dY < -40 && player.position.y <= 1.1) vy = CONFIG.jumpStr;
            if(dY > 40) { player.scale.y = 0.5; setTimeout(() => player.scale.y = 1, 600); }
        }
    });
}

function loop() {
    requestAnimationFrame(loop);
    const dt = clock.getDelta();
    if(mixer) mixer.update(dt);
    
    if(!gameActive) return;

    // Movement Logic
    player.position.z += CONFIG.moveSpeed;
    const roadX = Math.sin(player.position.z * 0.025) * 8;
    player.position.x += (roadX + (lane * CONFIG.laneDist) - player.position.x) * 0.15;

    // Gravity
    vy -= CONFIG.gravity;
    player.position.y += vy;
    if(player.position.y < 1) { player.position.y = 1; vy = 0; }

    // Camera
    camera.position.set(player.position.x * 0.6, 7, player.position.z - 12);
    camera.lookAt(player.position.x, 2, player.position.z + 15);

    // Infinite World Recycling
    if(player.position.z > tiles[0].position.z + CONFIG.tileLen) {
        let t = tiles.shift();
        t.position.z += tiles.length * CONFIG.tileLen + CONFIG.tileLen;
        t.position.x = Math.sin(t.position.z * 0.025) * 8;
        tiles.push(t);
        spawnTraps(t.position.z, t.position.x);
    }

    // Collision Detection
    obstacles.forEach((o, i) => {
        if(o.position.distanceTo(player.position) < 2.5) {
            if(o.position.y > 4 && player.scale.y < 0.6) return; // Slid Under
            gameActive = false;
            document.getElementById('dead-screen').style.display = 'flex';
        }
        if(o.position.z < player.position.z - 20) {
            scene.remove(o);
            obstacles.splice(i, 1);
        }
    });

    score += 0.5;
    document.getElementById('val').innerText = Math.floor(score);
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>

