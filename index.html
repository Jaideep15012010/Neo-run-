<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GALAXY TEMPLE: INFINITY</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; }
        #overlay { position: absolute; inset: 0; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); }
        .stat-box { position: absolute; top: 20px; right: 20px; color: gold; text-align: right; pointer-events: none; z-index: 50; }
        .joy-info { position: absolute; bottom: 80px; width: 100%; text-align: center; color: rgba(255,255,255,0.3); font-size: 12px; }
        button { background: linear-gradient(to bottom, #00f2fe, #4facfe); border: none; padding: 20px 60px; font-family: 'Orbitron'; font-size: 24px; border-radius: 10px; cursor: pointer; box-shadow: 0 10px 0 #0055aa; transition: 0.1s; }
        button:active { transform: translateY(5px); box-shadow: 0 5px 0 #0055aa; }
    </style>
</head>
<body>

<div id="overlay">
    <h1 style="color: #0ff; font-size: 40px; text-shadow: 0 0 20px #0ff;">GALAXY RUN 2</h1>
    <p style="color: #fff; opacity: 0.7;">TEMPLE ENGINE v4.0.1</p>
    <button onclick="Core.init()">PLAY MISSION</button>
</div>

<div class="stat-box">
    SCORE: <span id="ui-score">0</span><br>
    MULTIPLIER: x<span id="ui-mult">1</span>
</div>

<div class="joy-info">SWIPE: LEFT | RIGHT | JUMP | SLIDE</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/**
 * GALAXY TEMPLE ENGINE - MODULAR ARCHITECTURE
 * Author: Gemini Gaming Framework
 */

const Config = {
    laneWidth: 4,
    speed: 0.6,
    jumpForce: 0.22,
    gravity: 0.009,
    chunkSize: 40,
    maxChunks: 8
};

const Core = {
    active: false,
    score: 0,
    multiplier: 1,
    
    init() {
        document.getElementById('overlay').style.display = 'none';
        this.active = true;
        World.setup();
        Player.setup();
        Controls.bind();
        this.loop();
    },

    loop() {
        if(!Core.active) return;
        requestAnimationFrame(() => Core.loop());
        
        Player.update();
        World.update();
        UI.refresh();
        Renderer.render();
    }
};

const Renderer = {
    scene: new THREE.Scene(),
    camera: new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000),
    webGL: new THREE.WebGLRenderer({ antialias: true }),

    setup() {
        this.webGL.setSize(window.innerWidth, window.innerHeight);
        this.webGL.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(this.webGL.domElement);
        this.camera.position.set(0, 6, -10);
        this.scene.fog = new THREE.FogExp2(0x000510, 0.03);
        
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(5, 20, 10);
        this.scene.add(sun, new THREE.AmbientLight(0x404040, 0.6));
    },

    render() {
        this.camera.lookAt(Player.mesh.position.x, Player.mesh.position.y + 2, Player.mesh.position.z + 10);
        this.webGL.render(this.scene, this.camera);
    }
};

const Player = {
    mesh: null,
    lane: 0,
    vy: 0,
    isGrounded: true,
    state: 'run',

    setup() {
        const geo = new THREE.BoxGeometry(1.2, 1.8, 1.2);
        const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, roughness: 0.2 });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.y = 1;
        Renderer.scene.add(this.mesh);
    },

    update() {
        // Lane Movement
        const targetX = this.lane * Config.laneWidth;
        this.mesh.position.x += (targetX - this.mesh.position.x) * 0.15;
        
        // Forward Movement
        this.mesh.position.z += Config.speed;
        Renderer.camera.position.z += Config.speed;

        // Jump & Gravity
        this.vy -= Config.gravity;
        this.mesh.position.y += this.vy;

        if(this.mesh.position.y <= 1) {
            this.mesh.position.y = 1;
            this.vy = 0;
            this.isGrounded = true;
        }

        // 3D Tilt Effect
        this.mesh.rotation.z = (targetX - this.mesh.position.x) * 0.1;
        this.mesh.rotation.x = Config.speed * 0.2;
    }
};

const World = {
    chunks: [],
    obstacles: [],
    coins: [],

    setup() {
        for(let i=0; i<Config.maxChunks; i++) {
            this.spawnChunk(i * Config.chunkSize);
        }
    },

    spawnChunk(z) {
        const geo = new THREE.BoxGeometry(15, 1, Config.chunkSize);
        const mat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const floor = new THREE.Mesh(geo, mat);
        floor.position.set(0, 0, z + Config.chunkSize/2);
        Renderer.scene.add(floor);
        this.chunks.push(floor);

        // Spawn Assets on this chunk
        if(z > 40) this.populateChunk(z);
    },

    populateChunk(zOffset) {
        for(let i=0; i<3; i++) {
            const z = zOffset + (i * 12);
            if(Math.random() > 0.6) this.spawnObstacle(z);
            else this.spawnCoin(z);
        }
    },

    spawnObstacle(z) {
        const obs = new THREE.Mesh(
            new THREE.BoxGeometry(3, 4, 1),
            new THREE.MeshStandardMaterial({ color: 0xff0055 })
        );
        obs.position.set((Math.floor(Math.random()*3)-1)*Config.laneWidth, 2, z);
        Renderer.scene.add(obs);
        this.obstacles.push(obs);
    },

    spawnCoin(z) {
        const coin = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00 })
        );
        coin.position.set((Math.floor(Math.random()*3)-1)*Config.laneWidth, 1.5, z);
        Renderer.scene.add(coin);
        this.coins.push(coin);
    },

    update() {
        // Recycle Chunks
        if(Player.mesh.position.z > this.chunks[0].position.z + Config.chunkSize) {
            const old = this.chunks.shift();
            old.position.z += Config.maxChunks * Config.chunkSize;
            this.chunks.push(old);
            this.populateChunk(old.position.z - Config.chunkSize/2);
        }

        // Check Collisions
        this.obstacles.forEach((o, i) => {
            if(o.position.distanceTo(Player.mesh.position) < 1.8) Core.active = false;
        });

        this.coins.forEach((c, i) => {
            if(c.position.distanceTo(Player.mesh.position) < 1.5) {
                Renderer.scene.remove(c);
                this.coins.splice(i, 1);
                Core.score += 10;
                Config.speed += 0.0005;
            }
        });
    }
};

const Controls = {
    bind() {
        let tsX = 0, tsY = 0;
        window.addEventListener('touchstart', e => { 
            tsX = e.touches[0].clientX; 
            tsY = e.touches[0].clientY; 
        });
        window.addEventListener('touchend', e => {
            const dx = e.changedTouches[0].clientX - tsX;
            const dy = e.changedTouches[0].clientY - tsY;
            if(Math.abs(dx) > Math.abs(dy)) {
                if(dx > 40) Player.lane = Math.min(1, Player.lane+1);
                if(dx < -40) Player.lane = Math.max(-1, Player.lane-1);
            } else {
                if(dy < -40 && Player.isGrounded) {
                    Player.vy = Config.jumpForce;
                    Player.isGrounded = false;
                }
            }
        });
    }
};

const UI = {
    refresh() {
        document.getElementById('ui-score').innerText = Math.floor(Core.score);
    }
};

Renderer.setup();
</script>
</body>
</html>

